/**
 * Feedback command implementation for juno-task-ts CLI
 *
 * Provides comprehensive user feedback collection with TUI for bug reports,
 * feature requests, and general feedback. Integrates with USER_FEEDBACK.md
 * and supports both interactive and batch modes.
 */

import * as path from 'node:path';
import { promises as fs } from 'node:fs';
import chalk from 'chalk';
import { Command } from 'commander';

import type { FeedbackCommandOptions } from '../types.js';
import { FileSystemError, ValidationError } from '../types.js';

/**
 * Feedback entry structure
 */
interface FeedbackEntry {
  id: string;
  type: 'bug' | 'feature' | 'improvement' | 'question' | 'other';
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  tags: string[];
  timestamp: Date;
  status: 'new' | 'in_progress' | 'resolved' | 'wont_fix';
  metadata?: {
    sessionId?: string;
    reproduction?: string;
    expectedBehavior?: string;
    actualBehavior?: string;
    environment?: Record<string, string>;
  };
}

/**
 * Feedback file manager for USER_FEEDBACK.md manipulation
 */
class FeedbackFileManager {
  constructor(private filePath: string) {}

  async ensureExists(): Promise<void> {
    try {
      await fs.access(this.filePath);
    } catch {
      await this.createInitialFile();
    }
  }

  async loadEntries(): Promise<FeedbackEntry[]> {
    try {
      const content = await fs.readFile(this.filePath, 'utf-8');
      return this.parseMarkdown(content);
    } catch (error) {
      throw new FileSystemError(
        `Failed to read feedback file: ${error}`,
        this.filePath
      );
    }
  }

  async saveEntries(entries: FeedbackEntry[]): Promise<void> {
    try {
      const content = this.generateMarkdown(entries);
      await fs.writeFile(this.filePath, content, 'utf-8');
    } catch (error) {
      throw new FileSystemError(
        `Failed to write feedback file: ${error}`,
        this.filePath
      );
    }
  }

  async addEntry(entry: FeedbackEntry): Promise<void> {
    const entries = await this.loadEntries();
    entries.unshift(entry); // Add to top
    await this.saveEntries(entries);
  }

  async updateEntry(id: string, updates: Partial<FeedbackEntry>): Promise<boolean> {
    const entries = await this.loadEntries();
    const index = entries.findIndex(entry => entry.id === id);

    if (index === -1) {
      return false;
    }

    entries[index] = { ...entries[index], ...updates };
    await this.saveEntries(entries);
    return true;
  }

  async removeEntry(id: string): Promise<boolean> {
    const entries = await this.loadEntries();
    const filteredEntries = entries.filter(entry => entry.id !== id);

    if (filteredEntries.length === entries.length) {
      return false;
    }

    await this.saveEntries(filteredEntries);
    return true;
  }

  private async createInitialFile(): Promise<void> {
    const initialContent = `# User Feedback

This file contains feedback, bug reports, and feature requests for the project.
Items are automatically organized by status and can be managed using the \`juno-task feedback\` command.

## Active Items

*No active items*

## In Progress

*No items in progress*

## Resolved

*No resolved items*

---
*Generated by juno-task feedback system*
`;

    // Ensure directory exists
    const dir = path.dirname(this.filePath);
    await fs.mkdir(dir, { recursive: true });

    await fs.writeFile(this.filePath, initialContent, 'utf-8');
  }

  private parseMarkdown(content: string): FeedbackEntry[] {
    const entries: FeedbackEntry[] = [];

    // Improved parser to extract all feedback metadata
    const lines = content.split('\n');
    let currentEntry: Partial<FeedbackEntry> | null = null;
    let inCodeBlock = false;
    let currentSection = '';
    let currentDescription = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();

      // Track code blocks
      if (trimmed.startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }

      if (inCodeBlock) {
        continue;
      }

      // Track sections
      if (trimmed.startsWith('## ')) {
        currentSection = trimmed.substring(3).trim().toLowerCase();
        continue;
      }

      // Parse feedback entries
      if (trimmed.startsWith('### ')) {
        // Save previous entry
        if (currentEntry && currentEntry.id) {
          currentEntry.description = currentDescription.trim();
          entries.push(currentEntry as FeedbackEntry);
        }

        // Start new entry - extract title and emoji indicators
        const titleWithEmojis = trimmed.substring(4).trim();
        const title = this.extractTitle(titleWithEmojis);
        const priority = this.extractPriority(titleWithEmojis);
        const type = this.extractType(titleWithEmojis);

        currentEntry = {
          id: '', // Will be set when we find the ID line
          title,
          type,
          status: this.inferStatusFromSection(currentSection),
          description: '',
          priority,
          tags: [],
          timestamp: new Date()
        };
        currentDescription = '';
      } else if (currentEntry) {
        // Parse metadata lines
        if (trimmed.startsWith('**Tags:**')) {
          const tagsMatch = trimmed.match(/\*\*Tags:\*\*\s*(.+)/);
          if (tagsMatch) {
            currentEntry.tags = tagsMatch[1]
              .split(/[,\s]+/)
              .map(tag => tag.replace(/[`"']/g, '').trim())
              .filter(tag => tag.length > 0);
          }
        } else if (trimmed.startsWith('**Created:**')) {
          const dateMatch = trimmed.match(/\*\*Created:\*\*\s*(.+)/);
          if (dateMatch) {
            const dateStr = dateMatch[1].trim();
            currentEntry.timestamp = new Date(dateStr);
          }
        } else if (trimmed.startsWith('**ID:**')) {
          const idMatch = trimmed.match(/\*\*ID:\*\*\s*`([^`]+)`/);
          if (idMatch) {
            currentEntry.id = idMatch[1];
          }
        } else if (trimmed && !trimmed.startsWith('*') && !trimmed.startsWith('-') && !trimmed.startsWith('**')) {
          // Add to description
          if (currentDescription) {
            currentDescription += '\n' + trimmed;
          } else {
            currentDescription = trimmed;
          }
        }
      }
    }

    // Save last entry
    if (currentEntry && currentEntry.id) {
      currentEntry.description = currentDescription.trim();
      entries.push(currentEntry as FeedbackEntry);
    }

    return entries;
  }

  private extractTitle(titleWithEmojis: string): string {
    // Remove emoji indicators and extract clean title
    return titleWithEmojis
      .replace(/^[üêõ‚ú®üìà‚ùìüìù]\s*/, '') // Remove type emoji
      .replace(/\s*[üîµüü°üü†üî¥]\s*$/, '') // Remove priority emoji
      .trim();
  }

  private extractPriority(titleWithEmojis: string): FeedbackEntry['priority'] {
    if (titleWithEmojis.includes('üî¥')) return 'critical';
    if (titleWithEmojis.includes('üü†')) return 'high';
    if (titleWithEmojis.includes('üü°')) return 'medium';
    if (titleWithEmojis.includes('üîµ')) return 'low';
    return 'medium';
  }

  private extractType(titleWithEmojis: string): FeedbackEntry['type'] {
    if (titleWithEmojis.startsWith('üêõ')) return 'bug';
    if (titleWithEmojis.startsWith('‚ú®')) return 'feature';
    if (titleWithEmojis.startsWith('üìà')) return 'improvement';
    if (titleWithEmojis.startsWith('‚ùì')) return 'question';
    if (titleWithEmojis.startsWith('üìù')) return 'other';
    return 'other';
  }

  private generateMarkdown(entries: FeedbackEntry[]): string {
    const activeItems = entries.filter(e => e.status === 'new');
    const inProgressItems = entries.filter(e => e.status === 'in_progress');
    const resolvedItems = entries.filter(e => e.status === 'resolved');

    let content = `# User Feedback

This file contains feedback, bug reports, and feature requests for the project.
Items are automatically organized by status and can be managed using the \`juno-task feedback\` command.

## Active Items

`;

    if (activeItems.length === 0) {
      content += '*No active items*\n\n';
    } else {
      for (const item of activeItems) {
        content += this.formatEntry(item);
      }
    }

    content += '## In Progress\n\n';

    if (inProgressItems.length === 0) {
      content += '*No items in progress*\n\n';
    } else {
      for (const item of inProgressItems) {
        content += this.formatEntry(item);
      }
    }

    content += '## Resolved\n\n';

    if (resolvedItems.length === 0) {
      content += '*No resolved items*\n\n';
    } else {
      for (const item of resolvedItems) {
        content += this.formatEntry(item);
      }
    }

    content += `---
*Generated by juno-task feedback system*
*Last updated: ${new Date().toISOString()}*
`;

    return content;
  }

  private formatEntry(entry: FeedbackEntry): string {
    const priorityEmoji = {
      low: 'üîµ',
      medium: 'üü°',
      high: 'üü†',
      critical: 'üî¥'
    };

    const typeEmoji = {
      bug: 'üêõ',
      feature: '‚ú®',
      improvement: 'üìà',
      question: '‚ùì',
      other: 'üìù'
    };

    let content = `### ${typeEmoji[entry.type]} ${entry.title} ${priorityEmoji[entry.priority]}\n\n`;

    if (entry.description) {
      content += `${entry.description}\n\n`;
    }

    if (entry.tags.length > 0) {
      content += `**Tags:** ${entry.tags.map(tag => `\`${tag}\``).join(', ')}\n`;
    }

    content += `**Created:** ${entry.timestamp.toLocaleDateString()}\n`;
    content += `**ID:** \`${entry.id}\`\n\n`;

    return content;
  }

  private inferTypeFromSection(section: string): FeedbackEntry['type'] {
    if (section.includes('bug')) return 'bug';
    if (section.includes('feature')) return 'feature';
    if (section.includes('improvement')) return 'improvement';
    if (section.includes('question')) return 'question';
    return 'other';
  }

  private inferStatusFromSection(section: string): FeedbackEntry['status'] {
    if (section.includes('progress')) return 'in_progress';
    if (section.includes('resolved') || section.includes('done')) return 'resolved';
    return 'new';
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
}

/**
 * Interactive TUI for feedback collection
 */
class FeedbackTUI {
  private manager: FeedbackFileManager;

  constructor(manager: FeedbackFileManager) {
    this.manager = manager;
  }

  async collectFeedback(): Promise<FeedbackEntry> {
    console.log(chalk.blue.bold('\nüí¨ User Feedback Collection\n'));

    const entry: Partial<FeedbackEntry> = {
      id: this.generateId(),
      timestamp: new Date(),
      status: 'new',
      tags: []
    };

    // Get feedback type
    entry.type = await this.promptForType();

    // Get title
    entry.title = await this.promptForTitle();

    // Get description
    entry.description = await this.promptForDescription();

    // Get priority
    entry.priority = await this.promptForPriority();

    // Get tags
    entry.tags = await this.promptForTags();

    // Add metadata based on type
    if (entry.type === 'bug') {
      entry.metadata = await this.promptForBugMetadata();
    }

    return entry as FeedbackEntry;
  }

  async showFeedbackList(): Promise<void> {
    const entries = await this.manager.loadEntries();

    if (entries.length === 0) {
      console.log(chalk.yellow('No feedback entries found.'));
      return;
    }

    console.log(chalk.blue.bold('\nüìù Current Feedback Items\n'));

    const activeItems = entries.filter(e => e.status === 'new');
    const inProgressItems = entries.filter(e => e.status === 'in_progress');
    const resolvedItems = entries.filter(e => e.status === 'resolved');

    if (activeItems.length > 0) {
      console.log(chalk.yellow.bold('Active Items:'));
      this.displayEntries(activeItems);
      console.log('');
    }

    if (inProgressItems.length > 0) {
      console.log(chalk.blue.bold('In Progress:'));
      this.displayEntries(inProgressItems);
      console.log('');
    }

    if (resolvedItems.length > 0) {
      console.log(chalk.green.bold('Resolved:'));
      this.displayEntries(resolvedItems.slice(0, 5)); // Show only recent resolved items
      if (resolvedItems.length > 5) {
        console.log(chalk.gray(`   ... and ${resolvedItems.length - 5} more resolved items`));
      }
      console.log('');
    }
  }

  private async promptForType(): Promise<FeedbackEntry['type']> {
    console.log(chalk.yellow('üè∑Ô∏è  Feedback Type:'));
    console.log('   1. üêõ Bug Report');
    console.log('   2. ‚ú® Feature Request');
    console.log('   3. üìà Improvement Suggestion');
    console.log('   4. ‚ùì Question');
    console.log('   5. üìù Other');

    // In real implementation, would prompt for user input
    // For demonstration, return bug
    return 'bug';
  }

  private async promptForTitle(): Promise<string> {
    console.log(chalk.yellow('\nüìã Title:'));
    console.log('   Enter a brief, descriptive title for your feedback');

    // Default for demonstration
    return 'Example feedback item';
  }

  private async promptForDescription(): Promise<string> {
    console.log(chalk.yellow('\nüìù Description:'));
    console.log('   Provide detailed information about your feedback');
    console.log('   (Use Ctrl+D when finished)');

    // Default for demonstration
    return 'This is an example feedback description with detailed information.';
  }

  private async promptForPriority(): Promise<FeedbackEntry['priority']> {
    console.log(chalk.yellow('\n‚ö° Priority Level:'));
    console.log('   1. üîµ Low');
    console.log('   2. üü° Medium');
    console.log('   3. üü† High');
    console.log('   4. üî¥ Critical');

    // Default for demonstration
    return 'medium';
  }

  private async promptForTags(): Promise<string[]> {
    console.log(chalk.yellow('\nüè∑Ô∏è  Tags (optional):'));
    console.log('   Enter comma-separated tags (e.g., cli, performance, ui)');

    // Default for demonstration
    return ['cli', 'example'];
  }

  private async promptForBugMetadata(): Promise<FeedbackEntry['metadata']> {
    console.log(chalk.yellow('\nüêõ Bug Report Details:'));

    // In real implementation, would prompt for:
    // - Steps to reproduce
    // - Expected behavior
    // - Actual behavior
    // - Environment details

    return {
      reproduction: 'Steps to reproduce the bug',
      expectedBehavior: 'What should happen',
      actualBehavior: 'What actually happens',
      environment: {
        os: process.platform,
        node: process.version,
        junoTask: '1.0.0'
      }
    };
  }

  private displayEntries(entries: FeedbackEntry[]): void {
    for (const entry of entries) {
      const typeEmoji = {
        bug: 'üêõ',
        feature: '‚ú®',
        improvement: 'üìà',
        question: '‚ùì',
        other: 'üìù'
      };

      const priorityColor = {
        low: chalk.blue,
        medium: chalk.yellow,
        high: chalk.magenta,
        critical: chalk.red
      };

      const priorityText = priorityColor[entry.priority](entry.priority.toUpperCase());
      const typeText = `${typeEmoji[entry.type]} ${entry.type}`;
      const dateText = chalk.gray(entry.timestamp.toLocaleDateString());

      console.log(`   ${chalk.white.bold(entry.title)}`);
      console.log(`   ${typeText} | ${priorityText} | ${dateText} | ID: ${chalk.gray(entry.id)}`);

      if (entry.description.length > 100) {
        console.log(`   ${chalk.gray(entry.description.substring(0, 100))}...`);
      } else if (entry.description) {
        console.log(`   ${chalk.gray(entry.description)}`);
      }

      if (entry.tags.length > 0) {
        console.log(`   Tags: ${entry.tags.map(tag => chalk.cyan(`#${tag}`)).join(' ')}`);
      }

      console.log('');
    }
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }
}

/**
 * Main feedback command handler
 */
export async function feedbackCommandHandler(
  args: string[],
  options: FeedbackCommandOptions,
  command: Command
): Promise<void> {
  try {
    // Determine feedback file path
    const feedbackFile = options.file || path.join(process.cwd(), 'USER_FEEDBACK.md');
    const manager = new FeedbackFileManager(feedbackFile);

    // Ensure feedback file exists
    await manager.ensureExists();

    // Check if first argument is a known subcommand
    const knownSubcommands = ['list', 'ls', 'resolve', 'remove', 'rm'];
    const isSubcommand = args.length > 0 && knownSubcommands.includes(args[0]);

    if (!isSubcommand) {
      // Not a subcommand - add new feedback
      if (options.interactive) {
        const tui = new FeedbackTUI(manager);
        const entry = await tui.collectFeedback();
        await manager.addEntry(entry);

        console.log(chalk.green.bold('\n‚úÖ Feedback added successfully!'));
        console.log(chalk.gray(`   ID: ${entry.id}`));
        console.log(chalk.gray(`   File: ${feedbackFile}`));
      } else {
        // Quick feedback mode
        if (args.length === 0) {
          console.log(chalk.yellow('Please provide feedback text or use --interactive mode'));
          console.log(chalk.gray('Usage: juno-task feedback "Your feedback here"'));
          console.log(chalk.gray('   or: juno-task feedback --interactive'));
          return;
        }

        const feedbackText = Array.isArray(args) ? args.join(' ') : args;
        const entry: FeedbackEntry = {
          id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
          type: 'other',
          title: feedbackText.substring(0, 50) + (feedbackText.length > 50 ? '...' : ''),
          description: feedbackText,
          priority: 'medium',
          tags: ['cli'],
          timestamp: new Date(),
          status: 'new'
        };

        await manager.addEntry(entry);
        console.log(chalk.green.bold('‚úÖ Feedback added!'));
        console.log(chalk.gray(`   ID: ${entry.id}`));
        console.log(chalk.gray(`   File: ${feedbackFile}`));
      }
    } else {
      // Handle subcommands
      const subcommand = args[0];
      switch (subcommand) {
        case 'list':
        case 'ls':
          const tui = new FeedbackTUI(manager);
          await tui.showFeedbackList();
          break;

        case 'resolve':
          if (!args[1]) {
            console.log(chalk.red('Please provide feedback ID to resolve'));
            console.log(chalk.gray('Usage: juno-task feedback resolve <id>'));
            return;
          }

          const resolved = await manager.updateEntry(args[1], { status: 'resolved' });
          if (resolved) {
            console.log(chalk.green(`‚úÖ Feedback ${args[1]} marked as resolved`));
          } else {
            console.log(chalk.red(`‚ùå Feedback ${args[1]} not found`));
          }
          break;

        case 'remove':
        case 'rm':
          if (!args[1]) {
            console.log(chalk.red('Please provide feedback ID to remove'));
            console.log(chalk.gray('Usage: juno-task feedback remove <id>'));
            return;
          }

          const removed = await manager.removeEntry(args[1]);
          if (removed) {
            console.log(chalk.green(`‚úÖ Feedback ${args[1]} removed`));
          } else {
            console.log(chalk.red(`‚ùå Feedback ${args[1]} not found`));
          }
          break;

        default:
          console.log(chalk.red(`Unknown subcommand: ${subcommand}`));
          console.log(chalk.gray('Available subcommands: list, resolve, remove'));
      }
    }

  } catch (error) {
    if (error instanceof FileSystemError || error instanceof ValidationError) {
      console.error(chalk.red.bold('\n‚ùå Feedback Error'));
      console.error(chalk.red(`   ${error.message}`));

      if (error.suggestions?.length) {
        console.error(chalk.yellow('\nüí° Suggestions:'));
        error.suggestions.forEach(suggestion => {
          console.error(chalk.yellow(`   ‚Ä¢ ${suggestion}`));
        });
      }

      process.exit(1);
    }

    // Unexpected error
    console.error(chalk.red.bold('\n‚ùå Unexpected Error'));
    console.error(chalk.red(`   ${error}`));

    if (options.verbose) {
      console.error('\nüìç Stack Trace:');
      console.error(error);
    }

    process.exit(99);
  }
}

/**
 * Configure the feedback command for Commander.js
 */
export function configureFeedbackCommand(program: Command): void {
  program
    .command('feedback [text...]')
    .description('Collect and manage user feedback')
    .option('-f, --file <path>', 'Custom USER_FEEDBACK.md file path')
    .option('-i, --interactive', 'Launch interactive feedback collection')
    .action(async function(text, options, command) {
      // Get options from the command (local) and merge with parent (global) options
      const localOpts = command?.opts() || {};
      const parentOpts = command?.parent?.opts() || {};
      const mergedOptions = { ...parentOpts, ...localOpts, ...options };

      // Convert text to array if needed
      const textArray = text ? (Array.isArray(text) ? text : [text]) : [];
      await feedbackCommandHandler(textArray, mergedOptions as FeedbackCommandOptions, command);
    })
    .addHelpText('after', `
Subcommands:
  list, ls                    Show all feedback items
  resolve <id>                Mark feedback item as resolved
  remove <id>, rm <id>        Remove feedback item

Examples:
  $ juno-task feedback "The CLI is too slow"           # Quick feedback
  $ juno-task feedback --interactive                   # Interactive mode
  $ juno-task feedback list                           # List all feedback
  $ juno-task feedback resolve abc123                 # Resolve item abc123
  $ juno-task feedback remove abc123                  # Remove item abc123
  $ juno-task feedback --file ./custom-feedback.md    # Use custom file

Environment Variables:
  JUNO_TASK_FEEDBACK_FILE    Default feedback file path

Notes:
  - Feedback is stored in USER_FEEDBACK.md by default
  - Interactive mode provides guided collection
  - Items are automatically organized by status
  - Use feedback to communicate with your AI coding agents
    `);
}