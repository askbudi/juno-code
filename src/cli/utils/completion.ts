/**
 * Shell completion utilities for juno-task-ts CLI
 *
 * Provides shell completion script generation and installation for bash, zsh, and fish.
 * Supports command completion, option completion, and context-aware suggestions.
 */

import * as path from 'node:path';
import * as fs from 'fs-extra';
import * as os from 'node:os';
import chalk from 'chalk';

import type { ShellType, CompletionConfig } from '../types.js';

/**
 * Generate bash completion script
 */
function generateBashCompletion(commandName: string): string {
  return `#!/bin/bash

# ${commandName} completion script for bash
# Generated by juno-task-ts CLI

_${commandName}_completion() {
    local cur prev opts base
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Commands
    local commands="init start feedback session setup-git claude cursor codex gemini"

    # Global options
    local global_opts="--verbose --quiet --config --log-file --no-color --log-level --help --version"

    # Command-specific options
    case "\${COMP_WORDS[1]}" in
        init)
            opts="--force --task --subagent --git-url --interactive --template --var \$global_opts"
            ;;
        start)
            opts="--max-iterations --model --directory \$global_opts"
            ;;
        feedback)
            opts="--file --interactive \$global_opts"
            ;;
        session)
            local subcommands="list info remove clean"
            case "\${COMP_WORDS[2]}" in
                list|ls)
                    opts="--limit --subagent --status \$global_opts"
                    ;;
                info|show)
                    opts="\$global_opts"
                    ;;
                remove|rm|delete)
                    opts="--force \$global_opts"
                    ;;
                clean|cleanup)
                    opts="--days --empty --force \$global_opts"
                    ;;
                *)
                    opts="\$subcommands \$global_opts"
                    ;;
            esac
            ;;
        setup-git)
            opts="--show --remove \$global_opts"
            ;;
        claude|cursor|codex|gemini)
            opts="--max-iterations --model --cwd --interactive --interactive-prompt \$global_opts"
            ;;
        *)
            opts="\$commands \$global_opts"
            ;;
    esac

    # Handle option values
    case "\$prev" in
        --subagent)
            COMPREPLY=( \$(compgen -W "claude cursor codex gemini" -- \$cur) )
            return 0
            ;;
        --status)
            COMPREPLY=( \$(compgen -W "running completed failed cancelled" -- \$cur) )
            return 0
            ;;
        --log-level)
            COMPREPLY=( \$(compgen -W "error warn info debug trace" -- \$cur) )
            return 0
            ;;
        --config|--log-file)
            COMPREPLY=( \$(compgen -f -- \$cur) )
            return 0
            ;;
        --directory|--cwd)
            COMPREPLY=( \$(compgen -d -- \$cur) )
            return 0
            ;;
    esac

    COMPREPLY=( \$(compgen -W "\$opts" -- \$cur) )
    return 0
}

complete -F _${commandName}_completion ${commandName}
`;
}

/**
 * Generate zsh completion script
 */
function generateZshCompletion(commandName: string): string {
  return `#compdef ${commandName}

# ${commandName} completion script for zsh
# Generated by juno-task-ts CLI

_${commandName}() {
    local context state line
    typeset -A opt_args

    local commands=(
        'init:Initialize new juno-task project with template files'
        'start:Start execution using .juno_task/init.md as prompt'
        'feedback:Collect and manage user feedback'
        'session:Manage execution sessions'
        'setup-git:Configure Git repository and upstream URL'
        'claude:Execute with Claude subagent'
        'cursor:Execute with Cursor subagent'
        'codex:Execute with Codex subagent'
        'gemini:Execute with Gemini subagent'
    )

    local global_opts=(
        '(-v --verbose)'{-v,--verbose}'[Enable verbose output]'
        '(-q --quiet)'{-q,--quiet}'[Disable rich formatting]'
        '(-c --config)'{-c,--config}'[Configuration file path]:file:_files'
        '--log-file[Log file path]:file:_files'
        '--no-color[Disable colored output]'
        '--log-level[Log level]:level:(error warn info debug trace)'
        '(-h --help)'{-h,--help}'[Show help]'
        '(-V --version)'{-V,--version}'[Show version]'
    )

    _arguments -C \\
        "1: :->commands" \\
        "*: :->args" \\
        \$global_opts

    case \$state in
        commands)
            _describe 'commands' commands
            ;;
        args)
            case \$words[2] in
                init)
                    _arguments \\
                        '(-f --force)'{-f,--force}'[Force overwrite existing files]' \\
                        '(-t --task)'{-t,--task}'[Main task description]:task:' \\
                        '(-s --subagent)'{-s,--subagent}'[Preferred subagent]:subagent:(claude cursor codex gemini)' \\
                        '(-g --git-url)'{-g,--git-url}'[Git repository URL]:url:' \\
                        '(-i --interactive)'{-i,--interactive}'[Launch interactive setup]' \\
                        '--template[Template variant]:template:' \\
                        \$global_opts
                    ;;
                start)
                    _arguments \\
                        '(-m --max-iterations)'{-m,--max-iterations}'[Maximum iterations]:number:' \\
                        '--model[Model to use]:model:' \\
                        '(-d --directory)'{-d,--directory}'[Project directory]:directory:_directories' \\
                        \$global_opts
                    ;;
                feedback)
                    _arguments \\
                        '(-f --file)'{-f,--file}'[Custom feedback file]:file:_files' \\
                        '(-i --interactive)'{-i,--interactive}'[Interactive feedback collection]' \\
                        \$global_opts
                    ;;
                session)
                    local session_commands=(
                        'list:List all sessions'
                        'info:Show detailed session information'
                        'remove:Remove one or more sessions'
                        'clean:Clean up old/empty sessions'
                    )
                    _arguments \\
                        "1: :_describe 'session commands' session_commands" \\
                        \$global_opts
                    ;;
                setup-git)
                    _arguments \\
                        '(-s --show)'{-s,--show}'[Show current Git configuration]' \\
                        '(-r --remove)'{-r,--remove}'[Remove upstream URL]' \\
                        \$global_opts
                    ;;
                claude|cursor|codex|gemini)
                    _arguments \\
                        '(-m --max-iterations)'{-m,--max-iterations}'[Maximum iterations]:number:' \\
                        '--model[Model to use]:model:' \\
                        '--cwd[Working directory]:directory:_directories' \\
                        '(-i --interactive)'{-i,--interactive}'[Interactive mode]' \\
                        '--interactive-prompt[Launch TUI prompt editor]' \\
                        \$global_opts
                    ;;
            esac
            ;;
    esac
}

_${commandName} "\$@"
`;
}

/**
 * Generate fish completion script
 */
function generateFishCompletion(commandName: string): string {
  return `# ${commandName} completion script for fish
# Generated by juno-task-ts CLI

# Commands
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'init' -d 'Initialize new juno-task project'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'start' -d 'Start execution using init.md'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'feedback' -d 'Collect and manage feedback'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'session' -d 'Manage execution sessions'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'setup-git' -d 'Configure Git repository'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'claude' -d 'Execute with Claude'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'cursor' -d 'Execute with Cursor'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'codex' -d 'Execute with Codex'
complete -c ${commandName} -f -n '__fish_use_subcommand' -a 'gemini' -d 'Execute with Gemini'

# Global options
complete -c ${commandName} -s v -l verbose -d 'Enable verbose output'
complete -c ${commandName} -s q -l quiet -d 'Disable rich formatting'
complete -c ${commandName} -s c -l config -d 'Configuration file path' -r
complete -c ${commandName} -l log-file -d 'Log file path' -r
complete -c ${commandName} -l no-color -d 'Disable colored output'
complete -c ${commandName} -l log-level -d 'Log level' -xa 'error warn info debug trace'
complete -c ${commandName} -s h -l help -d 'Show help'
complete -c ${commandName} -s V -l version -d 'Show version'

# Init command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -s f -l force -d 'Force overwrite'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -s t -l task -d 'Main task description' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -s s -l subagent -d 'Preferred subagent' -xa 'claude cursor codex gemini'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -s g -l git-url -d 'Git repository URL' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -s i -l interactive -d 'Interactive setup'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from init' -l template -d 'Template variant' -r

# Start command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from start' -s m -l max-iterations -d 'Maximum iterations' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from start' -l model -d 'Model to use' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from start' -s d -l directory -d 'Project directory' -xa '(__fish_complete_directories)'

# Feedback command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from feedback' -s f -l file -d 'Custom feedback file' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from feedback' -s i -l interactive -d 'Interactive feedback'

# Session command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from session' -a 'list' -d 'List sessions'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from session' -a 'info' -d 'Show session info'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from session' -a 'remove' -d 'Remove sessions'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from session' -a 'clean' -d 'Clean up sessions'

# Setup-git command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from setup-git' -s s -l show -d 'Show Git config'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from setup-git' -s r -l remove -d 'Remove upstream URL'

# Subagent command options
complete -c ${commandName} -f -n '__fish_seen_subcommand_from claude cursor codex gemini' -s m -l max-iterations -d 'Maximum iterations' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from claude cursor codex gemini' -l model -d 'Model to use' -r
complete -c ${commandName} -f -n '__fish_seen_subcommand_from claude cursor codex gemini' -l cwd -d 'Working directory' -xa '(__fish_complete_directories)'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from claude cursor codex gemini' -s i -l interactive -d 'Interactive mode'
complete -c ${commandName} -f -n '__fish_seen_subcommand_from claude cursor codex gemini' -l interactive-prompt -d 'TUI prompt editor'
`;
}

/**
 * Generate completion script for specified shell
 */
export function generateCompletion(shell: ShellType, commandName: string): string {
  switch (shell) {
    case 'bash':
      return generateBashCompletion(commandName);
    case 'zsh':
      return generateZshCompletion(commandName);
    case 'fish':
      return generateFishCompletion(commandName);
    default:
      throw new Error(`Unsupported shell: ${shell}`);
  }
}

/**
 * Detect current shell
 */
export function detectShell(): ShellType {
  const shell = path.basename(process.env.SHELL || '');

  switch (shell) {
    case 'bash':
      return 'bash';
    case 'zsh':
      return 'zsh';
    case 'fish':
      return 'fish';
    default:
      // Default to bash if unknown
      return 'bash';
  }
}

/**
 * Get completion installation paths for different shells
 */
function getCompletionPaths(shell: ShellType, commandName: string): {
  scriptPath: string;
  sourceCommand: string;
} {
  const homeDir = os.homedir();

  switch (shell) {
    case 'bash':
      return {
        scriptPath: path.join(homeDir, '.bash_completions', `${commandName}.bash`),
        sourceCommand: `source ~/.bash_completions/${commandName}.bash`
      };

    case 'zsh':
      return {
        scriptPath: path.join(homeDir, '.zsh', 'completions', `_${commandName}`),
        sourceCommand: `fpath=(~/.zsh/completions $fpath)`
      };

    case 'fish':
      return {
        scriptPath: path.join(homeDir, '.config', 'fish', 'completions', `${commandName}.fish`),
        sourceCommand: '# Fish automatically loads completions from ~/.config/fish/completions/'
      };

    default:
      throw new Error(`Unsupported shell: ${shell}`);
  }
}

/**
 * Install completion script for specified shell
 */
export async function installCompletion(shell?: ShellType): Promise<void> {
  const detectedShell = shell || detectShell();
  const commandName = 'juno-task';

  console.log(chalk.blue(`Installing ${detectedShell} completion for ${commandName}...`));

  try {
    const { scriptPath, sourceCommand } = getCompletionPaths(detectedShell, commandName);
    const script = generateCompletion(detectedShell, commandName);

    // Ensure completion directory exists
    await fs.ensureDir(path.dirname(scriptPath));

    // Write completion script
    await fs.writeFile(scriptPath, script, 'utf8');

    console.log(chalk.green(`‚úÖ Completion script installed: ${scriptPath}`));

    // Provide shell-specific instructions
    switch (detectedShell) {
      case 'bash':
        console.log(chalk.blue('\nüìã Setup Instructions:'));
        console.log(chalk.white('Add this line to your ~/.bashrc or ~/.bash_profile:'));
        console.log(chalk.gray(`   ${sourceCommand}`));
        console.log(chalk.white('\nThen reload your shell or run:'));
        console.log(chalk.gray('   source ~/.bashrc'));
        break;

      case 'zsh':
        console.log(chalk.blue('\nüìã Setup Instructions:'));
        console.log(chalk.white('Add this line to your ~/.zshrc:'));
        console.log(chalk.gray(`   ${sourceCommand}`));
        console.log(chalk.white('\nThen reload your shell or run:'));
        console.log(chalk.gray('   source ~/.zshrc'));
        break;

      case 'fish':
        console.log(chalk.blue('\nüìã Setup Instructions:'));
        console.log(chalk.green('‚úÖ Fish completion is ready to use!'));
        console.log(chalk.white('Completions are automatically loaded from:'));
        console.log(chalk.gray(`   ${path.dirname(scriptPath)}`));
        console.log(chalk.white('\nRestart your shell or open a new terminal to activate.'));
        break;
    }

  } catch (error) {
    console.error(chalk.red(`‚ùå Failed to install completion: ${error}`));
    throw error;
  }
}

/**
 * Uninstall completion script
 */
export async function uninstallCompletion(shell?: ShellType): Promise<void> {
  const detectedShell = shell || detectShell();
  const commandName = 'juno-task';

  console.log(chalk.blue(`Uninstalling ${detectedShell} completion for ${commandName}...`));

  try {
    const { scriptPath } = getCompletionPaths(detectedShell, commandName);

    if (await fs.pathExists(scriptPath)) {
      await fs.remove(scriptPath);
      console.log(chalk.green(`‚úÖ Completion script removed: ${scriptPath}`));
    } else {
      console.log(chalk.yellow('‚ö†Ô∏è  Completion script not found'));
    }

  } catch (error) {
    console.error(chalk.red(`‚ùå Failed to uninstall completion: ${error}`));
    throw error;
  }
}

/**
 * Check if completion is installed
 */
export async function isCompletionInstalled(shell?: ShellType): Promise<boolean> {
  const detectedShell = shell || detectShell();
  const commandName = 'juno-task';

  try {
    const { scriptPath } = getCompletionPaths(detectedShell, commandName);
    return await fs.pathExists(scriptPath);
  } catch {
    return false;
  }
}